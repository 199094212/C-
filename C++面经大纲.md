## C++面经大纲

### C++基础知识

#### 基础语法

const的作用

> 1. 修饰变量，说明该变量不可以被改变；
> 2. 修饰指针，分为指向常量的指针和指针常量；
> 3. 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
> 4. 修饰成员函数，说明该成员函数内不能修改成员变量

static的作用:

>1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
>2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
>3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
>4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员

#pragma pack(n)

> 设定结构体、联合以及类成员变量以 n 字节方式对齐
>
> ```c++
> #pragma pack(push)  // 保存对齐状态
> #pragma pack(4)     // 设定为 4 字节对齐
> struct test
> {
>     char m1;
>     double m4;
>     int m3;
> };
> #pragma pack(pop)   // 恢复对齐状态
> ```

volatile

>- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
>- volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
>- const 可以是 volatile （如只读的状态寄存器）
>- 指针可以是 volatile

extern "C"

> - 被 extern 限定的函数或变量是 extern 类型的
> - 被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和连接的
>
> `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
>
> ```c++
> #ifdef __cplusplus
> extern "C" {
> #endif
> void *memset(void *, int, size_t);
> #ifdef __cplusplus
> }
> #endif
> ```

C++struct和class的区别

>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。
>
>最本质的一个区别就是默认的访问控制
>
>1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。
>2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

expliciit 关键字

> - explicit 修饰构造函数时，可以防止隐式转换和复制初始化
> - explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外





空类占用内存大小   

> 1个字节

------

智能指针：

> auto_ptr：
>
> shared_ptr：
>
> unique_ptr：
>
> weak_ptr：

------

weak_ptr 如何转shared_ptr?

>

------

C++的四种类型转换

>使用C 风格的类型转换可以把想要的任何东西转换成我们需要的类型，但是这种类型转换太过松散，对于这种松散的情况，C++ 提供了更严格的类型转换，可以提供更好的控制转换过程，并添加 4 个类型转换运算符，使转换过程更规范：static_cast、dynamic_cast、const_cast、reinterpret_cast。
>
>static_cast 静态转换
>
>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换
>
>o 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
>
>o 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的
>
>用于基本数据类型之间的转换，如把int 转换成 char，把 char 转换成 int。这种转换的安全性也要开发人员来保证
>
>dynamic_cast 动态转换
>
>dynamic_cast 主要用于类层次间的上行转换和下行转换
>
>在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的
>
>在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全
>
>const_cast 常量转换
>
>该运算符用来修改类型的const属性
>
>常量指针被转化成非常量指针，并且仍然指向原来的对象
>
>常量引用被转换成非常量引用，并且仍然指向原来的对象
>
>注意:不能直接对非指针和非引用的变量使用 const_cast 操作符
>
>reinterpret_cast 重新解释转换
>
>这是最不安全的一种转换机制，最有可能出问题
>
>主要用于将一种数据类型从一种类型转换为另一种类型，它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针

------

C++中的内存对齐

>主要就是struct的那一块。
>
>对于32位来说默认四字节对齐
>
>对于64位来说采用八字节对齐

------

#### 面向对象

动态多态的实现

说一说C++中哪些不能是虚函数

>C++ 中，普通函数（非成员函数）、构造函数、友元函数、静态成员函数、内联成员函数这些不能是虚函数。
>
>1.普通函数（非成员函数）
>
>2.构造函数
>
>3.友元函数
>
>4.静态成员函数
>
>5.内联成员函数

------

虚函数表运行时加载在虚拟地址空间的哪里？

> .rodata数据段

------



#### STL

STL常用容器

>STL 中容器分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：
>
>1、顺序容器
>
>容器并非排序的，元素的插入位置同元素的值无关，包含vector、deque、list。
>
>o vector：动态数组
>
>元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
>
>o deque：双向队列
>
>元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector ）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
>
>o list：双向链表
>
>元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
>
>2、关联式容器
>
>元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现，包含set、multiset、map、multimap。
>
>o set/multiset
>
>set中不允许相同元素，multiset 中允许存在相同元素。
>
>o map/multimap
>
>map 与 set 的不同在于 map 中存放的元素有且仅有两个成员变，一个名为 first，另一个名为 second，map 根据 first 值对元素从小到大排序，并可快速地根据 first 来检索元素。map 和multimap 的不同在于是否允许相同 first 值的元素。
>
>3、容器适配器
>
>封装了一些基本的容器，使之具备了新的函数功能，包含stack、queue、priority_queue。
>
>o stack：栈
>
>栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项），后进先出。
>
>o queue：队列
>
>插入只可以在尾部进行，删除、检索和修改只允许从头部进行，先进先出。
>
>o priority_queue：优先级队列
>
>内部维持某种有序，然后确保优先级最高的元素总是位于头部，最高优先级元素总是第一个出列。

------

#### C++11

shared ptr的引用计数对象在哪里？栈上还是堆上

> 堆

unique-ptr和scoped-ptr什么区别？

> 就比unique ptr少了那个带右值引用的拷贝构造和重载赋值。

实现getSharedPtr让使技术引用为2

> ```cpp
> #include<iostream>
> #include<memory>
> using namespace std;
> /*代码*/
> class A:public enable_shared_from_this<A>{
> public:
>         shared_ptr<A> getSharedPtr()    
>         {
>                  return shared_from_this();
>         }
>    };
> int main()
> {
>      shared_ptr<A> ptr1(new A());
>          shared_ptr<A> ptr2  = ptr1->getSharedPtr();
>         cout<<ptr1.use_count()<<endl;
>         cout<<ptr2.use_count()<<endl;
>         return 0;
>    }
>    ```

### linux

进程间通信的方式？

>1、无名管道
>
>2、有名管道
>
>3、消息队列
>
>4、信号量数组
>
>5、共享内存
>
>6、socket通信



- IO多路复用

    > - 什么是IO多路复用?
    >
    > ​	IO多路复用可以同时监听多个文件描述符，能够提高程序的性能，linux下实现I/O多路复用的系统调用主要有：select、poll、epoll。
    >
    > - IO模型：
    >
    >     - 阻塞等待（BIO）：
    >
    >         基本的read、write，采用多线程或者多进程解决
    >
    >         缺点：1、线程或者进程会消耗资源；2、线程或进程调度消耗CPU资源
    >
    >     - 非阻塞，忙轮询（NIO模型）：
    >
    >         提高了程序的执行效率，采用IO多路复用解决。
    >
    >         缺点：需要占用更多的CPU和系统资源。
    >
    > 	- 多路复用IO
    > 	
    > 	    - select：
    > 	
    > 	        > 主旨思想： 
    > 	        >
    > 	        > 1. 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。
    > 	        >
    > 	        > 2. 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O 操作时，该函数才返回。
    > 	        >
    > 	        >     a.这个函数是阻塞
    > 	        >
    > 	        >     b.函数对文件描述符的检测的操作是由内核完成的 
    > 	        >
    > 	        > 3. 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。
    > 	        >
    > 	        > 缺点：
    > 	        >
    > 	        > - 每次要将fdset从用户态拷贝到内核态，当fd比较多这个开销会很大。
    > 	        > - 内核需要遍历所有文件描述符，在文件描述符很多的时候开销比较大。
    > 	        > - select支持的文件描述符数量太少，默认是1024。
    > 	        > - fds集合不能重用每次都要重置。
    > 	
    > 	    - poll
    > 	
    > 	        > ```cpp
    > 	        > #include <poll.h>
    > 	        > struct pollfd {
    > 	        > int fd; /* 委托内核检测的文件描述符 */
    > 	        > short events; /* 委托内核检测文件描述符的什么事件 */
    > 	        > short revents; /* 文件描述符实际发生的事件 */
    > 	        > };
    > 	        > struct pollfd myfd;
    > 	        > myfd.fd = 5;
    > 	        > myfd.events = POLLIN | POLLOUT;
    > 	        > int poll(struct pollfd *fds, nfds_t nfds, int timeout);
    > 	        > - 参数：
    > 	        > 	- fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合
    > 	        > 	- nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1
    > 	        > 	- timeout : 阻塞时长
    > 	        > 		0 : 不阻塞
    > 	        > 		-1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞
    > 	        > 		>0 : 阻塞的时长
    > 	        > - 返回值：
    > 	        > 	-1 : 失败
    > 	        > 	>0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化
    > 	        > ```
    > 	        >
    > 	        > ![image-20220221193122268](C:\Users\HP\Desktop\image-20220221193122268.png)
    > 	
    > 	    - epoll
    > 	
    > 	        > 1、采用红黑树
    > 	        >
    > 	        > 2、epoll底层在内核中，减少了用户态到内核态拷贝的动作。
    > 	        >
    > 	        > ```cpp
    > 	        > include <sys/epoll.h>
    > 	        > // 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检
    > 	        > 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。
    > 	        > int epoll_create(int size);
    > 	        > 	- 参数：
    > 	        > 		size : 目前没有意义了。随便写一个数，必须大于0
    > 	        > 	- 返回值：
    > 	        >         -1 : 失败
    > 	        >         > 0 : 文件描述符，操作epoll实例的
    > 	        > 
    > 	        > typedef union epoll_data {
    > 	        >     void *ptr;
    > 	        >     int fd;
    > 	        >     uint32_t u32;
    > 	        >     uint64_t u64;
    > 	        > } epoll_data_t;
    > 	        > struct epoll_event {
    > 	        >     uint32_t events; /* Epoll events */
    > 	        >     epoll_data_t data; /* User data variable */
    > 	        > };
    > 	        > 常见的Epoll检测事件：
    > 	        >     - EPOLLIN
    > 	        >     - EPOLLOUT
    > 	        >     - EPOLLERR
    > 	        > // 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息
    > 	        > int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    > 	        >     - 参数：
    > 	        >         - epfd : epoll实例对应的文件描述符
    > 	        >         - op : 要进行什么操作
    > 	        >             EPOLL_CTL_ADD: 添加
    > 	        >             EPOLL_CTL_MOD: 修改
    > 	        >             EPOLL_CTL_DEL: 删除
    > 	        >      - fd : 要检测的文件描述符
    > 	        >      - event : 检测文件描述符什么事情
    > 	        > // 检测函数
    > 	        > int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    > 	        >     - 参数：
    > 	        >         - epfd : epoll实例对应的文件描述符
    > 	        >         - events : 传出参数，保存了发送了变化的文件描述符的信息
    > 	        >         - maxevents : 第二个参数结构体数组的大小
    > 	        >         - timeout : 阻塞时间
    > 	        >             - 0 : 不阻塞
    > 	        >             - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞
    > 	        >             - > 0 : 阻塞的时长（毫秒）
    > 	        >     - 返回值：
    > 	        >         - 成功，返回发送变化的文件描述符的个数 > 0
    > 	        >                 - 失败 -1
    > 	        > ```
    > 	        >
    > 	        > - 水平触发LT：
    > 		        >
    > 	        >     > 
    >	        >
    > 	        > - 边沿触发ET：
    >	        >
    > 	        >     >
    > 	        
    >	        
    > 
    >

- 



### 计算机网络

#### 网络基础

OSI七层模型

> OSI 模型（Open System Interconnection Model）是⼀个由 ISO 提出得到概念模型，试图提供⼀个使各种 不同的的计算机和⽹络在世界范围内实现互联的标准框架。
>
> | 网络层次 | 常用协议 | 传输方式 |功能|
> | :------- | ----------------------- | -------- |------|
> | 应用层   | HTTP、SMTP、FTP、TELNET |  |这⼀层为操作系统或⽹络应⽤程序提供访问⽹络服务的接⼝。|
> | 表示层   |                         |  |使通信的应用程序能够解释交换数据的含义，说图像、视频编码解，数据加密。|
> | 会话层   | SSL、TLS                |          |管理主机之间的会话进程，即负责建⽴、管理、终⽌进程之间的会话|
> | 运输层   | TCP、UDP                | 数据段 ||
> | 网络层   | IP、ARP、ICMP、IGMP     | 数据包 ||
> | 链路层   |                         | 将 bit 流封装成 frame 帧 |不可靠的物理介质上提供可靠的传输。|
> | 物理层   |                         | bit 流 |确保原始的数据可在各种物理媒体上传输|
>
> 

#### 网络层



#### 传输层

运输层的功能？

> 运输层协议会运行在不同主机上的应用进程提供逻辑通信的功能*/

TCP和UDP的区别

>1、从首部来看：UDP只占8个字节而TCP占20个字节
>
>2、从连接来看：TCP是面向连接的而UDP无连接
>
>3、从发送数据类型来看：UDP发送的是数据报，而TCP发送的是字节流
>
>4、从数据安全来看：TCP保证数据正确性，UDP可能丢包
>
>5、TCP保证数据顺序，UDP不保证。

#### 应用层

协议：

>DNS:
>
>>
>
>HTTP:
>
>>
>
>HTTPS:
>
>>
>
>SMTP:
>
>>

1、tcp黏包问题

>

2、浏览器打开网站的过程

>

3、网站渲染

>



### 操作系统



### 计算机组成原理

堆和栈的区别？

>1、栈是从上往下生长的，而堆是从下往上生长的
>
>2、栈由系统自动分配，而堆是人为申请开辟
>
>3、栈是连续的空间，而堆是不一定连续。
>
>4、栈获得的空间较小，而堆获得的空间较大



### 数据库

#### MySQL

常见的存储引擎：MYISAM、InnoDB、MEMORY

MYISAM和InnoDB的区别

| 对比项 | MyISAM                                             | InnoDB                             |
| ------ | -------------------------------------------------- | ---------------------------------- |
| 主外键 | 不支持                                             | 支持                               |
| 事物   | 不支持                                             | 支持                               |
| 行表锁 | 表锁，即使操作一条记录也会锁住整个表，不适合高并发 | 行锁，操作时锁住某一行，适合高并发 |
| 缓存   | 只缓存索引，不缓存真实数据                         | 既缓存索引，又缓存真实数据         |
| 表空间 | 小                                                 | 大                                 |
| 关注点 | 性能                                               | 事物                               |

MYSQL事物

>事物的特性：ACID
>
>原子性：是指事务包含的所有操作要么全部成功，要么全部失败回滚。
>
>一致性：是指一个事务执行之前和执行之后都必须处于一致性状态。
>
>隔离性：跟隔离级别相关，如`read committed`，一个事务只能读到已经提交的修改。
>
>持久性：是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

> 脏读：**脏读**是指在一个事务处理过程里读取了另一个未提交的事务中的数据。
>
> 不可重复度：**不可重复读**是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。
>
> 幻读：**幻读**是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。

数据库的隔离级别：

> 读未提交：所有事务都可以看到其他未提交事务的执行结果。  无法避免 脏读、幻读、不可重复读
>
> 读已提交：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
>
> 可重复读：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
>
> 串行化：通过强制事务[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，使之不可能相互冲突，从而解决幻读问题。

性能下降慢SQL

> 查询语句写的烂
>
> 索引失效
>
> 关联查询太多
>
> 服务器调优及各个参数设置（缓存，线程数等）

索引

- 什么是索引

    >索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。

- 索引的优缺点？

    > 优点：
    >
    > - **加快数据查找的速度**
    > - 为用来[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)或者是分组的字段添加索引，可以加快分组和[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)的速度
    > - 加快表与表之间的连接
    >
    > 缺点：
    >
    > - 建立索引需要**占用物理空间**
    > - 会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行**动态维护索引**，导致增删改时间变长

- 索引的分类

    > 单值索引：即一个索引值包含单个例，一个表可以有多个单例索引
    >
    > 唯一索引：
    >
    > 复合索引：
    >
    > 基本语法：

​	

#### Redis

​	

### 中间件

